<!DOCTYPE html>

<html>

<head>
    <title>Collisions - Physijs</title>

    <link rel="stylesheet" type="text/css" href="css/styles.css" />

    <script type="text/javascript" src="js/three.min.js"></script>
    <script type="text/javascript" src="js/stats.js"></script>
    <script type="text/javascript" src="physi.js"></script>
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

    <script type="text/javascript">

        'use strict';

        Physijs.scripts.worker = 'physijs_worker.js';
        Physijs.scripts.ammo = 'js/ammo.js';

        var initScene, render, loader, box_geometry, box, material,
            renderer, scene, ground_material, ground, ground1, ground2, ground3, ground4,
            initEventHandling, camera, intersect_plane,
            selected = null, mouse_position = new THREE.Vector3, block_offset = new THREE.Vector3, _v3 = new THREE.Vector3;

        initScene = function() {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.shadowMap.enabled = true;
            renderer.shadowMapSoft = true;
            document.getElementById( 'viewport' ).appendChild( renderer.domElement );

            scene = new Physijs.Scene;
            scene.setGravity(new THREE.Vector3( 0, 0, 0 ));
            scene.addEventListener(
                'update',
                function() {
                    if ( selected !== null ) {

                        _v3.copy( mouse_position ).add( block_offset ).sub( selected.position ).multiplyScalar( 5 );
                        _v3.y = 0;
                        selected.setLinearVelocity( _v3 );

                        box.applyCentralImpulse( _v3 );
                    }
                    scene.simulate( undefined, 1 );
                }
            );

            camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set( 0, 100, 0 );
            camera.lookAt( scene.position );
            scene.add( camera );

            // Loader
            loader = new THREE.TextureLoader();

            // Ground
            ground_material = Physijs.createMaterial(new THREE.MeshBasicMaterial({transparent: true}), 0.8, 0.3);

            ground = new Physijs.BoxMesh(new THREE.BoxGeometry(1000, 0.5, 1000), ground_material, 0 );
            scene.add( ground );

            ground1 = new Physijs.BoxMesh(new THREE.PlaneGeometry(200, 200, 200, 200), ground_material);
            ground1.position.set(0,0,-60);
            ground1.rotation.set(.5,0,0);
            scene.add( ground1 );

            ground2 = new Physijs.BoxMesh(new THREE.PlaneGeometry(200, 200, 200, 200), ground_material);
            ground2.position.set(0,0,60);
            ground2.rotation.set(-0.5,0,0);
            scene.add( ground2 );

            ground3 = new Physijs.BoxMesh(new THREE.PlaneGeometry(200, 200, 200, 200), ground_material);
            ground3.position.set(-28,0,0);
            ground3.rotation.set(0,1.57,0);
            scene.add( ground3 );

            ground4 = new Physijs.BoxMesh(new THREE.PlaneGeometry(200, 200, 200, 200), ground_material);
            ground4.position.set(25,0,0);
            ground4.rotation.set(0,1.57,0);
            scene.add( ground4 );

            box_geometry = new THREE.BoxGeometry( 9, 9, 9 );

            var color = new THREE.MeshFaceMaterial([
                new THREE.MeshBasicMaterial({map:loader.load("images/1.png")}),
                new THREE.MeshBasicMaterial({map:loader.load("images/2.png")}),
                new THREE.MeshBasicMaterial({map:loader.load("images/3.png")}),
                new THREE.MeshBasicMaterial({map:loader.load("images/4.png")}),
                new THREE.MeshBasicMaterial({map:loader.load("images/5.png")}),
                new THREE.MeshBasicMaterial({map:loader.load("images/6.png")})
            ]);

            material = Physijs.createMaterial( color, 0.6, 0.3 );

            box = new Physijs.BoxMesh( box_geometry, material);
            box.collisions = 0;

            box.position.set(0, 40, 0);

            box.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );

            scene.add( box );

            intersect_plane = new THREE.Mesh(
                new THREE.PlaneGeometry( 150, 150 ),
                new THREE.MeshBasicMaterial({ opacity: 0, transparent: true })
            );
            intersect_plane.rotation.x = Math.PI / -2;
            scene.add( intersect_plane );
            initEventHandling();

            requestAnimationFrame( render );
            scene.simulate();
        };

        render = function() {
            requestAnimationFrame( render );
            renderer.render( scene, camera );
        };

        initEventHandling = (function() {
            var _vector = new THREE.Vector3,
                handleMouseDown, handleMouseMove, handleMouseUp;
            var raycaster = new THREE.Raycaster();

            handleMouseDown = function( event ) {
                var vector = new THREE.Vector3(
                    ( event.clientX / window.innerWidth ) * 2 - 1,
                    - ( event.clientY / window.innerHeight ) * 2 + 1, 1 );
                vector.unproject( camera );
                raycaster.set( camera.position, vector.sub( camera.position ).normalize() );
                var intersects = raycaster.intersectObject( box );

                if ( intersects.length > 0 ) {
                    selected = intersects[ 0 ].object;

                    _vector.set( 0, 0, 0 );
                    selected_block.setAngularFactor( _vector );
                    selected_block.setAngularVelocity( _vector );
                    selected_block.setLinearFactor( _vector );
                    selected_block.setLinearVelocity( _vector );
                    mouse_position.copy( intersections[0].point );
                    block_offset.subVectors( selected_block.position, mouse_position );

                    intersect_plane.position.y = mouse_position.y;
                }
            };

            handleMouseMove = function( evt ) {

                var ray, intersection;

                if ( selected !== null ) {

                    _vector.set(
                        ( evt.clientX / window.innerWidth ) * 2 - 1,
                        -( evt.clientY / window.innerHeight ) * 2 + 1, 1
                    );
                    _vector.unproject( camera );

                    ray = new THREE.Raycaster( camera.position, _vector.sub( camera.position ).normalize() );
                    intersection = ray.intersectObject( intersect_plane );
                    mouse_position.copy( intersection[0].point );
                }

            };

            handleMouseUp = function(  ) {

                if ( selected !== null ) {
                    box.setAngularVelocity(
                        new THREE.Vector3(
                            Math.random() * Math.PI,
                            Math.random() * Math.PI,
                            Math.random() * Math.PI
                        )
                    );
                    scene.setGravity(new THREE.Vector3( 0, -30, 0 ));
                    selected = null;
                }

            };

            return function() {
                renderer.domElement.addEventListener( 'mousedown', handleMouseDown );
                renderer.domElement.addEventListener( 'mousemove', handleMouseMove );
                renderer.domElement.addEventListener( 'mouseup', handleMouseUp );
            };
        })();

        window.onload = initScene;

    </script>
</head>

<body>
<div id="viewport"></div>
</body>

</html>