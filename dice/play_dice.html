<!DOCTYPE html>

<html>

<head>
    <title>Collisions - Physijs</title>

    <link rel="stylesheet" type="text/css" href="css/styles.css" />

    <script type="text/javascript" src="js/three.min.js"></script>
    <script type="text/javascript" src="js/stats.js"></script>
    <script type="text/javascript" src="physi.js"></script>
    <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>

    <script type="text/javascript">

        'use strict';

        Physijs.scripts.worker = 'physijs_worker.js';
        Physijs.scripts.ammo = 'js/ammo.js';

        var initScene, render, loader, box_geometry, box, material,
            renderer, scene, ground_material, ground, camera, selected;

        initScene = function() {
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.shadowMap.enabled = true;
            renderer.shadowMapSoft = true;
            document.getElementById( 'viewport' ).appendChild( renderer.domElement );

            scene = new Physijs.Scene;
            scene.setGravity(new THREE.Vector3( 0, -30, 0 ));
            scene.addEventListener(
                'update',
                function() {
                    scene.simulate( undefined, 1 );
                }
            );

            camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.set( 60, 50, 60 );
            camera.lookAt( scene.position );
            scene.add( camera );

            // Loader
            loader = new THREE.TextureLoader();

            // Ground
            ground_material = Physijs.createMaterial(new THREE.MeshBasicMaterial({color: 0x0}), 0.8, 0.3);

            ground = new Physijs.BoxMesh(new THREE.BoxGeometry(1000, 0.5, 1000), ground_material, 0 );
            ground.depthWrite = false;
            scene.add( ground );

            box_geometry = new THREE.BoxGeometry( 9, 9, 9 );

            var color = new THREE.MeshFaceMaterial([
                new THREE.MeshBasicMaterial({map:loader.load("images/1.png")}),
                new THREE.MeshBasicMaterial({map:loader.load("images/2.png")}),
                new THREE.MeshBasicMaterial({map:loader.load("images/3.png")}),
                new THREE.MeshBasicMaterial({map:loader.load("images/4.png")}),
                new THREE.MeshBasicMaterial({map:loader.load("images/5.png")}),
                new THREE.MeshBasicMaterial({map:loader.load("images/6.png")})
            ]);

            material = Physijs.createMaterial( color, 0.6, 0.3 );

            box = new Physijs.BoxMesh( box_geometry, material);
            box.collisions = 0;

            box.position.set(8, 25, 8);

            box.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );

            scene.add( box );

            requestAnimationFrame( render );

            var raycaster = new THREE.Raycaster();
            var plane = new THREE.Plane();
            var intersection = new THREE.Vector3();
            var offset = new THREE.Vector3();
            var mouse = new THREE.Vector2();

            document.getElementById( 'viewport' ).appendChild( renderer.domElement ).addEventListener('mousedown', function(event) {

                var vector = new THREE.Vector3(
                    ( event.clientX / window.innerWidth ) * 2 - 1,
                    - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 );
                vector.unproject( camera );
                raycaster.set( camera.position, vector.sub( camera.position ).normalize() );

                var intersects = raycaster.intersectObject( box );
                if ( intersects.length > 0 ) {
                    selected = intersects[ 0 ].object;
                }
            });

            document.getElementById( 'viewport' ).appendChild( renderer.domElement ).addEventListener('mousemove', function(event) {
                event.preventDefault();
                var rect = renderer.domElement.getBoundingClientRect();
                mouse.x = ( ( event.clientX - rect.left ) / rect.width ) * 2 - 1;
                mouse.y = - ( ( event.clientY - rect.top ) / rect.height ) * 2 + 1;
                raycaster.setFromCamera( mouse, camera );
                if (selected) {
                    if ( raycaster.ray.intersectPlane( plane, intersection ) ) {
                        selected.position.copy( intersection.sub( offset ) );
                    }
                    scene.add(box);
                }
            });

            document.getElementById( 'viewport' ).appendChild( renderer.domElement ).addEventListener('mouseup', function() {
                selected = null;
                scene.simulate();
            });
        };

        render = function() {
            requestAnimationFrame( render );
            renderer.render( scene, camera );
        };

        window.onload = initScene;

    </script>
</head>

<body>
<div id="viewport"></div>
</body>

</html>